from typing import Dict, Any, List, Optional
from pathlib import Path
from tarotai.core.models.types import CardMeaning, Reading
from tarotai.ai.clients.base import BaseAIClient
from tarotai.ai.clients.providers.voyage import VoyageClient
from .knowledge.golden_dawn import GoldenDawnKnowledgeBase
from .knowledge.image_processor import GoldenDawnImageProcessor
from .reading_history import ReadingHistoryManager
from .exceptions import EnrichmentError

class EnrichmentManager:
    """Centralized enrichment management system"""
    
    def __init__(self, ai_client: BaseAIClient, voyage_client: VoyageClient):
        self.ai_client = ai_client
        self.voyage_client = voyage_client
        self.gd_knowledge = GoldenDawnKnowledgeBase(
            pdf_path=Path("data/golden_dawn.pdf"),
            voyage_client=voyage_client
        )
        self.image_processor = GoldenDawnImageProcessor(voyage_client)
        self.history_manager = ReadingHistoryManager()
        
    async def enrich_card(self, card: CardMeaning) -> CardMeaning:
        """Enrich a single card with additional knowledge"""
        try:
            # Get Golden Dawn knowledge
            gd_info = await self.gd_knowledge.get_card_info(card.name)
            
            # Generate enhanced meanings
            card.upright_meaning = await self._generate_enhanced_meaning(
                card, gd_info, is_reversed=False
            )
            card.reversed_meaning = await self._generate_enhanced_meaning(
                card, gd_info, is_reversed=True
            )
            
            # Generate embeddings
            card.embeddings = await self._generate_embeddings(card)
            
            return card
            
        except Exception as e:
            raise EnrichmentError(f"Failed to enrich card {card.name}: {str(e)}")
            
    async def _generate_enhanced_meaning(
        self,
        card: CardMeaning,
        gd_info: Dict[str, Any],
        is_reversed: bool = False
    ) -> str:
        """Generate enhanced meaning using AI and Golden Dawn knowledge"""
        prompt = f"""
        Generate a { 'reversed' if is_reversed else 'upright' } meaning for {card.name} considering:
        - Element: {card.element}
        - Astrological: {card.astrological}
        - Kabbalistic: {card.kabbalistic}
        - Golden Dawn Symbolism: {gd_info.get('symbolism', [])}
        - Traditional Meanings: {gd_info.get('traditional_meanings', [])}
        """
        return await self.ai_client.generate_response(prompt)
        
    async def _generate_embeddings(self, card: CardMeaning) -> Dict[str, Any]:
        """Generate multimodal embeddings for a card"""
        embeddings = {
            "text": await self.voyage_client.generate_embedding(
                f"{card.upright_meaning} {card.reversed_meaning}"
            )
        }
        
        if card.image_url:
            content = [
                {"type": "text", "text": card.upright_meaning},
                {"type": "image_url", "image_url": card.image_url}
            ]
            embeddings["multimodal"] = await self.voyage_client.generate_multimodal_embedding(content)
            
        return embeddings
        
    async def enrich_reading(self, reading: Reading) -> Reading:
        """Enrich a complete reading with additional insights"""
        try:
            # Enrich individual cards
            enriched_cards = []
            for card, is_reversed in reading.cards:
                enriched_card = await self.enrich_card(card)
                enriched_cards.append((enriched_card, is_reversed))
                
            # Update reading with enriched cards
            reading.cards = enriched_cards
            
            # Generate reading-level embeddings
            reading.embeddings = await self._generate_reading_embeddings(reading)
            
            # Add to history
            self.history_manager.add_reading(reading)
            
            return reading
            
        except Exception as e:
            raise EnrichmentError(f"Failed to enrich reading: {str(e)}")
            
    async def _generate_reading_embeddings(self, reading: Reading) -> Dict[str, Any]:
        """Generate hierarchical embeddings for a reading"""
        # Generate card embeddings
        card_embeddings = []
        for card, _ in reading.cards:
            card_embeddings.append(card.embeddings["text"])
            
        # Generate position embeddings
        position_embeddings = await self.voyage_client.generate_batch_embeddings(
            [f"Position {i}" for i in range(len(reading.cards))]
        )
        
        # Generate context embedding
        context = " ".join(card[0].upright_meaning for card in reading.cards)
        context_embedding = await self.voyage_client.generate_embedding(context)
        
        return {
            "card_embeddings": card_embeddings,
            "position_embeddings": position_embeddings,
            "context_embedding": context_embedding
        }
from tarotai.core.errors import TarotError

class EnrichmentError(TarotError):
    """Base class for enrichment-related errors"""
    pass

class KnowledgeBaseError(EnrichmentError):
    """Errors related to knowledge base operations"""
    pass

class EmbeddingError(EnrichmentError):
    """Errors during embedding generation"""
    pass

class ImageProcessingError(EnrichmentError):
    """Errors during image processing"""
    pass
from typing import Dict, Any, List, Optional
from pathlib import Path
import json
from tarotai.core.errors import EnrichmentError
from tarotai.ai.clients.providers.voyage import VoyageClient

class GoldenDawnKnowledgeBase:
    """Knowledge base for Golden Dawn tarot interpretations"""
    
    def __init__(self, pdf_path: Path, voyage_client: VoyageClient):
        self.pdf_path = pdf_path
        self.voyage_client = voyage_client
        self.knowledge = self._load_knowledge()
        self.embeddings = self._generate_embeddings()
        
    def _load_knowledge(self) -> Dict[str, Any]:
        """Load Golden Dawn knowledge from JSON file"""
        try:
            with open(self.pdf_path.with_suffix('.json'), 'r') as f:
                return json.load(f)
        except Exception as e:
            raise EnrichmentError(f"Failed to load Golden Dawn knowledge: {str(e)}")
            
    def _generate_embeddings(self) -> Dict[str, Any]:
        """Generate embeddings for knowledge base sections"""
        embeddings = {}
        for section, content in self.knowledge.items():
            text = f"{section}: {content['description']}"
            embeddings[section] = self.voyage_client.generate_embedding(text)
        return embeddings
        
    async def get_card_info(self, card_name: str) -> Dict[str, Any]:
        """Get Golden Dawn knowledge for a specific card"""
        try:
            return self.knowledge.get(card_name, {})
        except Exception as e:
            raise EnrichmentError(f"Failed to get card info for {card_name}: {str(e)}")
            
    async def find_similar_cards(self, query: str, top_k: int = 3) -> List[Dict[str, Any]]:
        """Find cards similar to the query using semantic search"""
        try:
            query_embedding = await self.voyage_client.generate_embedding(query)
            similarities = []
            
            for card, embedding in self.embeddings.items():
                similarity = await self.voyage_client.calculate_similarity(
                    query_embedding, embedding
                )
                similarities.append((card, similarity))
                
            # Sort by similarity and return top_k results
            similarities.sort(key=lambda x: x[1], reverse=True)
            return [
                {"card": card, "similarity": similarity}
                for card, similarity in similarities[:top_k]
            ]
            
        except Exception as e:
            raise EnrichmentError(f"Failed to find similar cards: {str(e)}")
